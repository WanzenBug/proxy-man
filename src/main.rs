use actix_web::App;
use actix_web::dev::HttpResponseBuilder;
use actix_web::get;
use actix_web::http::StatusCode;
use actix_web::HttpServer;
use actix_web::Responder;
use actix_web::web;
use serde::Deserialize;

#[derive(Deserialize)]
struct Rule {
    regex: String,
    proxy: String,
}

#[get("/")]
async fn index(web::Query(rules): web::Query<Vec<Rule>>) -> impl Responder {
    let mut resp = String::from("// generated by pac-man\n");
    resp.push_str("function FindProxyForURL(url, host){");

    for rule in rules {
        if rule.regex.contains("/") {
            return HttpResponseBuilder::new(StatusCode::BAD_REQUEST)
                .body("No slashes allowed in regex");
        }


        resp.push_str("if(/^");
        resp.push_str(&rule.regex);
        resp.push_str("$/.test(host)){return \"PROXY ");
        resp.push_str(&rule.proxy);
        resp.push_str("\"}");
    }

    resp.push_str("return \"DIRECT\";}");
    return HttpResponseBuilder::new(StatusCode::OK)
        .content_type("application/x-ns-proxy-autoconfig")
        .body(resp);
}

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    let mut args = std::env::args();
    let _appname = args.next().expect("program name must exist");
    let iface = args.next().unwrap_or_else(|| "0.0.0.0:8080".to_string());
    HttpServer::new(|| App::new().service(index))
        .bind(iface)?
        .run()
        .await
}
